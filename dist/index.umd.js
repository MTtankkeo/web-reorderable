!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).Reodeerable={})}(this,(function(e){"use strict";var t;!function(e){e[e.NONE=0]="NONE",e[e.REORDERING=1]="REORDERING",e[e.REORDERED=2]="REORDERED"}(t||(t={}));class n extends HTMLElement{constructor(){super(...arguments),this._listeners=[]}set onChange(e){null!=e&&this.addListener(e)}addListener(e){console.assert(!this._listeners.includes(e),"Already exists a given callback."),this._listeners.push(e)}removeListener(e){console.assert(this._listeners.includes(e),"Already not exists a given callback."),this._listeners.push(e)}createState(e){return{items:e}}connectedCallback(){var e;const t=[];for(let n=0;n<this.children.length;n++){const s=this.children.item(n),r=null!==(e=s.getAttribute("key"))&&void 0!==e?e:s.getAttribute("reorderable-key");if(!r)throw new Error("Should be defining key attributes missing from reorderable element items so that items can be identified.");t.push({key:r,element:s})}this.onInit(),this.onUpdateState(this.createState(t))}}class s extends n{onInit(){console.log("on init")}onUpdateState(e){console.log("on update state",e)}onUpdateContext(e){console.log(e)}}customElements.define("reorderable-list",s);class r extends HTMLElement{connectedCallback(){this.onInit(),this.onInitEvent()}onInit(){let e=this.parentElement;for(;e;){if(e instanceof n)return this.target=e;e=e.parentElement}throw new Error("<reorderable-drag> must have a reorderable ancestor element.")}onInitEvent(){}}customElements.define("reorderable-drag",r);const i=new CSSStyleSheet;i.insertRule("\n    reorderable-list {\n        display: flex;\n        flex-direction: column;\n    }\n"),i.insertRule("\n    reorderable-grid {}\n"),document.adoptedStyleSheets=[i],e.ReorderableDragElement=r,e.ReorderableElement=n,e.ReorderableGridElement=class{},e.ReorderableListElement=s}));
//# sourceMappingURL=index.umd.js.map
