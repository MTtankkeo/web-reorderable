!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).Reodeerable={})}(this,(function(e){"use strict";var t,s;e.ReorderableItemStatus=void 0,(t=e.ReorderableItemStatus||(e.ReorderableItemStatus={})).NONE="none",t.READY="ready",t.ACTIVE="active";class n{get status(){return this._status}set status(e){this.status!=e&&(this._status=e)}constructor(t){this.parent=t,this._status=e.ReorderableItemStatus.NONE,console.assert(null!=t,"The given parent must be not null.")}registerPointerEvent(t){switch(this.status){case e.ReorderableItemStatus.NONE:return this.startedPointerEvent=null,this.currentPointerEvent=null;case e.ReorderableItemStatus.READY:return this.startedPointerEvent=t;case e.ReorderableItemStatus.ACTIVE:return this.currentPointerEvent=t}}}!function(e){e.NONE="none",e.REORDERING="reordering",e.REORDERED="reordered"}(s||(s={}));class r extends HTMLElement{constructor(){super(...arguments),this._listeners=[],this._statusListeners=[],this._status=s.NONE,this._state=null}get status(){return this._status}set status(e){this._status!=e&&this.notifyStatusListeners(this._status=e)}get state(){return this._state}set state(e){this.onUpdateState(this._state=e)}set onChange(e){null!=e&&this.addListener(e)}addListener(e){console.assert(!this._listeners.includes(e),"Already exists a given callback."),this._listeners.push(e)}removeListener(e){console.assert(this._listeners.includes(e),"Already not exists a given callback."),this._listeners.push(e)}addStatusListener(e){console.assert(!this._statusListeners.includes(e),"Already exists a given callback."),this._statusListeners.push(e)}removeStatusListener(e){console.assert(this._statusListeners.includes(e),"Already not exists a given callback."),this._statusListeners.push(e)}notifyListeners(e,t,s){this._listeners.forEach((n=>n(e,t,s)))}notifyStatusListeners(e){this._statusListeners.forEach((t=>t(e)))}static ancestorOf(e){let t=e.parentElement;for(;t;){if(t instanceof r)return t;t=t.parentElement}}createState(e){return{items:e.map((e=>new n(e)))}}onInit(){}onInitState(t){for(const s of t.items){const t=s.parent.element;t.addEventListener("pointerdown",(t=>{s.status=e.ReorderableItemStatus.READY,s.registerPointerEvent(t)})),t.addEventListener("pointermove",(t=>{s.status!=e.ReorderableItemStatus.READY&&s.status!=e.ReorderableItemStatus.ACTIVE||(s.status=e.ReorderableItemStatus.ACTIVE,s.registerPointerEvent(t))})),t.addEventListener("pointerup",(()=>s.status=e.ReorderableItemStatus.NONE)),t.addEventListener("pointercancel",(()=>s.status=e.ReorderableItemStatus.NONE))}}connectedCallback(){var e;const t=[];for(let s=0;s<this.children.length;s++){const n=this.children.item(s),r=null!==(e=n.getAttribute("key"))&&void 0!==e?e:n.getAttribute("reorderable-key");if(!r)throw new Error("Should be defining key attributes missing from reorderable element items so that items can be identified.");t.push({key:r,element:n})}this.onInit(),this.onInitState(this.state=this.createState(t))}}class a extends HTMLElement{constructor(){super(...arguments),this.connectedElements=[]}static ancestorOf(e){let t=e.parentElement;for(;t;){if(t instanceof a)return t;t=t.parentElement}}attach(e){console.assert(!this.connectedElements.includes(e),"Already a given element connected."),this.connectedElements.push(e)}detach(e){console.assert(!this.connectedElements.includes(e),"Already a given element not connected."),this.connectedElements.push(e)}connectedCallback(){queueMicrotask((()=>{if(0==this.connectedElements.length)throw new Error("Current the reorderable elements are not connected, so they are unnecessary in the element-tree.")}))}}customElements.define("reorderable-connection",a);class i extends r{onInit(){var e;console.log("on init"),null===(e=a.ancestorOf(this))||void 0===e||e.attach(this)}onUpdateState(e){console.log("on update state",e)}onUpdateContext(e){console.log(e)}}customElements.define("reorderable-list",i);class o extends HTMLElement{connectedCallback(){this.onInit(),this.onInitEvent()}onInit(){if(!r.ancestorOf(this))throw new Error("<reorderable-drag> must have a reorderable ancestor element.")}onInitEvent(){}}customElements.define("reorderable-drag",o);const l=new CSSStyleSheet;l.insertRule("\n    reorderable-list {\n        display: flex;\n        flex-direction: column;\n    }\n"),l.insertRule("\n    reorderable-grid {}\n"),document.adoptedStyleSheets=[l],e.ReorderableConnectionElement=a,e.ReorderableDragElement=o,e.ReorderableElement=r,e.ReorderableGridElement=class{},e.ReorderableItemState=n,e.ReorderableListElement=i}));
//# sourceMappingURL=index.umd.js.map
